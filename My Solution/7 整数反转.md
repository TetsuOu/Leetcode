# 题目

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

> 示例 1:
>输入: 123
> 输出: 321
> 
>  示例 2:
>输入: -123
> 输出: -321
> 
> 示例 3:
>输入: 120
> 输出: 21

注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[-2^{31},  2^{31} − 1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reverse-integer
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 解题思路

没什么特殊的算法。常规方法逆转数字。

注意处理溢出问题。

这里用C++测试的时候，int存储的数据超过2147483647(2^31-1)就会报错。Java不会。

所以需要预判一下。

先考虑正数：

int的最大数INT_MAX是2147483647

假设翻转后的数为res，res大于INT_MAX就算溢出

假设上一步的翻转数为res'，进行预判断：

- res'>214748364，res一定会溢出
- res'=214748364，需进一步判断最后一位加进来的数字也就是原数字的第一位，设为top。若top>7，res一定会溢出；否则，不会溢出。
- res'<214748364，res不会溢出

再考虑负数，和正数类似：

int的最小数INT_MIN是-2147483648
- res'<-214748364，res一定会溢出
- res'=-214748364，需进一步判断最后一位加进来的数字也就是原数字的第一位，设为top。若top<-8，res一定会溢出；否则，不会溢出。
- res'>-214748364，res不会溢出



# 代码

1、假设溢出不会报错

```C++
class Solution {
public:
    int reverse(int x) {
        int tmp,ans=0;
        while(x!=0){
            tmp=ans;
            ans=ans*10+x%10;
            if(ans/10!=tmp) return 0;//溢出后的值与预想中的值不会相同
            x=x/10;
        }
        return ans;    
    }
};
```

## AC代码

2、预判溢出

```c++
class Solution {
public:
    int reverse(int x) {
        int res = 0;
		while(x!=0){		
            if(res>214748364 || (res==214748364 && x%10>7)) return 0;
            if(res<-214748364 || (res==-214748364 && x%10<-8)) return 0;
            res=res*10+x%10;
            x=x/10;
        }		
        return res;
    }
};
```

